#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#pragma warning(disable : 4996)
enum Stats;
typedef enum Stats stats;
void printAllArmourEquipped();
void clear() {
	printf("\nPress ENTER key to Continue\n");
	getchar();
	system("cls");
}

void printStatInfoScreen() {
	printf("Health: \tthe amount of damage you can take before a game over\n"
		"Strength: \tthe amount of damage you can deal with a physical attack\n"
		"Agility: \ta number to determine how often you can attack in combat\n"
		"Defence: \tthe amount the damage can be reduced by when physically attacked\n"
		"Magic Defence:\tthe amount the damage can be reduced by when magically attacked\n"
		"Magic Attack: \tthe amount of damage you can deal with a magical attack\n"
		"Intel: \ta number used in random events and determine the skill points granted\n");
	getchar();
	clear();
}

int returnValidImport(int maxChoice) {
	char choice;
	do {
		printf("Enter a valid choice\n");
		scanf(" %c", &choice);
		if (choice == '/') {
			printStatInfoScreen();
			return -1;
		}
		else if (choice == '*') {
			printAllArmourEquipped();
		}

	} while (choice < 48 || choice > 48 + maxChoice);
	return (choice - 48);
}

void printIntroScreen() {
	printf("Fight for the Right by Weston\n"
		"_______________________________\n\n");
	clear();
	printf(
		"In this game, you have been sentenced\n"
		"to a life of fighting for other's amusement\n"
		"with a few catches.\n"
		"_______________________________\n\n");
	clear();
	printf(
		"When you wake each morning, you will have\n"
		"fight an on par opponent. If you live\n"
		"you are given some freedoms until nightfall.\n"
		"Your health is restored at the end of each night.\n"
		"End of game can occur anywhere, in the arena or market\n"
		"At any prompts, you can press [/] for Information on stats,\n"
		"[*] for equipment, and this game is\n"
		"meant to be played with a numpad.\n "
		"_______________________________\n\n");
	clear();
}

void printPlayerHeader(int *array) {
	printf("Player Stats -\t");
	printf("%d:Health\t", array[0]);
	printf("%d:Strength\t", array[1]);
	printf("%d:Agility\t", array[2]);
	printf("%d:Defence\t", array[3]);
	printf("%d:MagicDefence\t", array[4]);
	printf("%d:Magic\t\n", array[5]);
}

void printEnemyHeader(int *array) {
	printf("Enemy Stats -\t ");
	printf("%d:Health\t", array[0]);
	printf("%d:Strength\t", array[1]);
	printf("%d:Agility\t", array[2]);
	printf("%d:Defence\t", array[3]);
	printf("%d:MagicDefence\t", array[4]);
	printf("%d:Magic\t\n", array[5]);
}

void printDefending() {
	printf("The Enemy is getting ready to attack!\nHow would you like to defend?\n");
	printf("[0] Physical\n[1] Magic\n");
}

void printPlayerAttack() {
	printf("You can attack.\nPick your choice of attack\n");
	printf("[0] Physical\n[1] Magic\n");
}

void printStatUpgrade() {
	printf("Press the number for the skill you would like to upgrade\n");
	printf("[0] Health\n");
	printf("[1] Strength\n");
	printf("[2] Agility\n");
	printf("[3] Defence\n");
	printf("[4] MagicDefence\n");
	printf("[5] MagicAttack\n");
	printf("[6] Intel\n");
}


void printEndGame() {
	system("cls");
	printf("Thank you for playing.\n");
}


void printMainMenu() {
	printf("Would you like to start a new game?\n"
		"[0] Start New Game\n"
		"[1] Continue Game\n"
		"[2] Quit Game\n");
}

void printGodsBlessing(char *c) {
	printf("You have received %s blessing\n", c);
}

void printGodBlessedWStat() {
	printf("The gods have blessed your stats\n");
}

void printGodBlessedWArmour() {
	printf("The gods have blessed you with armour.\n");
}

void printArmourSwap() {
	printf("Would you like to swap your current armour?\n"
		"[0] Yes\n"
		"[1] No\n");

}

void printGodsStatue(char *gods) {
	printf("You approach the statue of %s.\n"
		"What would you like to do?\n"
		"[0] Request a blessing\n"
		"[1] Leave the statue\n"
		"[2] Challenge the god\n", gods);

}

void printShop(char *shopType) {
	printf("You approach a %s shop.\n"
		"What would you like to do?\n"
		"[0] See what the shop has to offer\n"
		"[1] Leave\n", shopType);

}

void printHome() {
	printf("You approach a home.\n"
		"What would you like to do?\n"
		"[0] Knock on the door\n"
		"[1] Leave\n");

}

void printCardinalTile(char *north, char *east, char *south, char *west) {
	printf("What direction would you like to go?\n");
	printf("[0] %s is north\n"
		"[1] %s is east\n"
		"[2] %s is south\n"
		"[3] %s is west\n",
		north, east, south, west);


}

int getRootRoundedUp(int n) {
	int i;
	for (i = 0; i * i < n; i++) {

	}
	return i;
}

int returnRoundedFloat(float n) {
	int i = 0;
	for (i = 0; i < n; i++) {}
	return i;
}

int fib(int n) {
	int a = 0, b = 1, c, i;
	if (n == 0)
		return a;
	for (i = 2; i <= n; i++) {
		c = a + b;
		a = b;
		b = c;
	}
	return b;
}

int return2Power(int n) {
	int i = 2;
	int number = 1;
	while (i < n) {
		i *= 2;
		number++;
	}
	return number;
}

typedef enum {
	false, true
} bool;
int playerData[8];

/* 0-> Health
 * 1-> Strength
 * 2-> Speed
 * 3-> Defence
 * 4-> Magic Def
 * 5-> Magic Attack
 * 6-> Intel
 * 7-> Gold
 * 8-> Score
 * */
char *boolPrint(bool b) {
	return b == false ? "false" : "true";
}

typedef enum ArmourID armourID;

enum ArmourID {
	Helm, Chestplate, Legplates, Gloves, Boots, Weapon
};

char *returnArmourType(armourID armourId) {
	switch (armourId) {
	case Helm:
		return "Helm";
	case Chestplate:
		return "Chestplate";
	case Legplates:
		return "Legplates";
	case Gloves:
		return "Pair of Gloves";
	case Boots:
		return "Pair of Boots";
	case Weapon:
		return "Weapon";
	default:
		return "Null";
	}
}

enum Stats {
	Health = 0, Strength, Agility, Defence, MagicDefence, Magic, Intel, Completed
};


char *returnStat(enum Stats stats) {
	switch (stats) {
	case Health:
		return "Health";
	case Strength:
		return "Strength";
	case Agility:
		return "Agility";
	case Defence:
		return "Defence";
	case Magic:
		return "Magic Attack";
	case MagicDefence:
		return "Magical Defence";
	case Intel:
		return "Intel";
	default:
		return "";
	}

}

typedef enum Stats stats;

typedef struct Armour {
	int boostValue;
	stats statOne;
	stats statTwo;
	armourID armourSlot;
} armour;
static armour playerArmour[6];

int getArmourBoost(armourID armourId) {
	return playerArmour[armourId].boostValue;
}

int getBoostedStatOne(armourID armourId) {
	return playerArmour[armourId].statOne;
}

int getBoostedStatTwo(armourID armourId) {
	return playerArmour[armourId].statTwo;
}

void printAllArmourEquipped() {
	int i;
	for (i = 0; i <= 5; i++) {
		printf("Slot id: %d BonusValue: %d "
			"StatOne: %d StatTwo: %d \n",
			i,
			getArmourBoost(i),
			getBoostedStatOne(i),
			getBoostedStatTwo(i));

	}
}

void printSwapArmour(armour armour) {
	armourID temp = armour.armourSlot;
	printf("Found a %s that boosts %s and %s by %d.\n",
		returnArmourType(armour.armourSlot),
		returnStat(armour.statOne),
		returnStat(armour.statTwo),
		armour.boostValue);
	printf("Current %s boosts %s and %s by %d.\n",
		returnArmourType(temp),
		returnStat(playerArmour[temp].statOne),
		returnStat(playerArmour[temp].statTwo),
		playerArmour[temp].boostValue
	);
}

void printArmour(armour *armour) {
	int i = 0;
	while (i < 3) {

		printf("[%d] %s that boosts %s and %s by %d.\n",
			i,
			returnArmourType(armour[i].armourSlot),
			returnStat(armour[i].statOne),
			returnStat(armour[i].statTwo),
			armour[i].boostValue);
		i++;
	}
	printf("[3] Leave Shop\n");
}

void setArmour(armour newArmour) {
	armourID temp = newArmour.armourSlot;
	playerArmour[temp] = newArmour;
}

int avgArmourStats() {
	int sum = 0, i;
	for (i = 1; i <= 6; i++) {
		sum += playerArmour[i].boostValue;
	}
	return sum / 6;

}

int returnValidImport(int maxChoice);

void swapArmourPrompt(armour armour);

void shopArmour(armourID id) {
	armour shopArmour[3];
	int i = 0;
	while (i < 3) {
		int maxBoostValue = avgArmourStats() * 1.25;
		shopArmour[i].armourSlot = id;
		shopArmour[i].boostValue = rand() % maxBoostValue + 10;
		shopArmour[i].statTwo = rand() % 7;
		shopArmour[i].statOne = rand() % 7;
		i++;
	}
	printArmour(shopArmour);
	int choice = returnValidImport(3);
	if (choice != 3) {
		swapArmourPrompt(shopArmour[choice]);
	}
}

int getSumEnemiesStats();

int enemies[6];

int avgBaseStats() {
	int sum = 0;
	int i = 0;
	while (i <= 6) {
		sum += playerData[i];
		i++;
	}
	return sum / 6;
}

void setInitialEnemies() {
	int avgStats = avgBaseStats();
	int *ptr = enemies;
	int i;
	for (i = 0; i <= 6; i++) {
		int r = rand() % (2 * getRootRoundedUp(avgStats));
		switch (i) {
		case 0:
			*ptr = (avgStats + getRootRoundedUp(avgStats) - r);
			break;
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
			*(ptr + i) = 2 * (avgStats)+getRootRoundedUp(avgStats) - r - *(ptr + i - 1);
			break;
		case 6:
			*(ptr + i) = avgStats * 6 - getSumEnemiesStats();
		default:
			break;

		}
	}

}

int getSumEnemiesStats() {
	int avg = 0, i = 0;
	for (i = 0; i < 6; i++) {
		avg += enemies[i];
	}
	return avg;
}

int getEnemyValueAtN(int n) {
	return enemies[n];
}

int getECombatAttackValue(int typeAttack) {
	if (typeAttack == 0) {
		return enemies[1];
	}
	else if (typeAttack == 1) {
		return enemies[5];
	}
	else return 0;
}

int getECombatDefenceValue(int typeAttack) {
	if (typeAttack == 0) {
		return enemies[3];
	}
	else if (typeAttack == 1) {
		return enemies[4];
	}
	else return 0;
}

enum godsBlessingID {
	Hermes = 0, Hephaestus, Ares, Cronos, Apollo,
	Dionysus, Prometheus, Poseidon, Hades, Zeus
};
typedef enum godsBlessingID ID;

char *returnGodBlessing(ID n) {
	switch (n) {
	case Hermes:
		return "Hermes";
	case Hephaestus:
		return "Hephaestus";
	case Ares:
		return "Ares";
	case Cronos:
		return "Cronos";
	case Apollo:
		return "Apollo";
	case Dionysus:
		return "Dionysus";
	case Prometheus:
		return "Prometheus";
	case Poseidon:
		return "Poseidon";
	case Hades:
		return "Hades";
	case Zeus:
		return "Zeus";
	default:
		return "Null";
	}
}

struct godsBlessing {
	stats statOne;
	int statOneBoost;
	stats statTwo;
	int statTwoBoost;
	armourID armourId;
	int intelMin;
	double chanceForBlessing;
	double chanceForArmour;
	bool hasBlessed;
};
static struct godsBlessing godsArray[10] = {
		{Agility,  35, Intel,        15, Boots,
													 45,  75,  15, false}, //Hermes
		{Strength, 40, Defence,      25, Chestplate, 45,
														  75,  85, false}, //Hephaestus
		{Strength, 25, Health,       25, Legplates,
													 95,  15,  85, false}, //Ares
		{Strength, 35, Intel,        25, Helm,       105,
														  75,  25, false}, //Cronos
		{Health,   25, Intel,        20, Gloves,
													 85,  95,  10, false}, //Apollo
		{Defence,  15, MagicDefence, 15, Gloves,
													 45,  100, 85, false}, //Dionysus
		{Agility,  25, Intel,        35, Boots,
													 50,  28,  60, false},// Prometheus
		{Health,   15, MagicDefence, 35, Chestplate,
													 125, 85,  20, false}, //Poseidon
		{Defence,  35, MagicDefence, 25, Legplates,
													 65,  15,  85},//Hades
		{Strength, 45, Magic,        35, Helm,       105,
														  65,  15
		}
};

void setTempPlayerData();

stats returnBoostOne(ID n) {
	return godsArray[n].statOne;
}

stats returnBoostTwo(ID n) {
	return godsArray[n].statTwo;
}

int returnBoostAmountOne(ID n) {
	return godsArray[n].statOneBoost;
}

int returnBoostAmountTwo(ID n) {
	return godsArray[n].statTwoBoost;
}

armourID returnArmourID(ID n) {
	return godsArray[n].armourId;
}

armour returnGodsArmour(ID n) {
	armour newArmour;
	newArmour.statOne = returnBoostOne(n);
	newArmour.statTwo = returnBoostTwo(n);
	newArmour.boostValue = (returnBoostAmountOne(n) + returnBoostAmountTwo(n)) / 2;
	newArmour.armourSlot = returnArmourID(n);
	return newArmour;
}

int maxa(int x, int y) {
	if (x > y) {
		return x;
	}
	else {
		return y;
	}
}

int mina(int x, int y) {
	if (x < y) {
		return x;
	}
	else {
		return y;
	}
}

int returnLCM(int x, int y) {
	int lar = maxa(x, y);
	int small = mina(x, y);
	int i;
	for (i = lar;; i += lar) {
		if (i % small == 0)
			return i;
	}
}

bool hasBlessing(ID n) {
	if (rand() % 100 < godsArray[n].chanceForBlessing) {

		return true;
	}
	else {
		printf("The gods reject you at this time.\n");
		return false;
	}
}

bool receiveArmour(ID n) {
	if (rand() % 100 < godsArray[n].chanceForArmour) {

		return true;
	}
	else {
		return false;
	}
}

static int tempPlayerData[6];

void placeArmourOnTemp() {
	int i;
	for (i = 0; i <= 5; i++) {
		tempPlayerData[
			playerArmour[i].statOne] += playerArmour[i].boostValue;
			tempPlayerData[
				playerArmour[i].statTwo] += playerArmour[i].boostValue;
	}
}

void printCombatHeader(int tempPlayerData[], int enemies[]) {
	system("cls");
	printPlayerHeader(tempPlayerData);
	printEnemyHeader(enemies);
}

int getEnemyAttackChoice() {
	return rand() % 2;
} //Return 0 or 1 for enemyAttack Choice
int getPlayerDefenceChoice() {
	int choice;
	do {
		printDefending();
		choice = returnValidImport(1);
	} while (choice == -1);
	return choice;
} //Return 0 or 1 for defence choice
int getEnemyDefenceChoice() {
	return rand() % 2;
} //Return 0 or 1 for enemydefence choice
int getPlayerAttackChoice() {
	int choice;
	do {
		printPlayerAttack();
		choice = returnValidImport(1);
	} while (choice == -1);
	return choice;
} //Return 0 or 1 for attack choice
int returnDamage(int a, int d, double m) {
	double damage = (a * 10) / (d + 10) * m;
	return returnRoundedFloat((float)damage);
}

void modPlayerStats(int stat, int statChange) {
	int *ptr = &playerData[stat];
	*ptr += statChange;
	setTempPlayerData();
}

int getPCombatAttackValue(int typeAttack) {
	return tempPlayerData[(typeAttack == 0 ? 1 : 5)];
}

int getPCombatDefenceValue(int typeAttack) {
	return tempPlayerData[(typeAttack == 0 ? 3 : 4)];
}

void attackingThePlayer() {
	int attackChoice = getEnemyAttackChoice();
	int defChoice = getPlayerDefenceChoice();
	double m;
	if (attackChoice == defChoice) {
		printf("The enemy blindsided you.\n");
		m = 0.75;
	}
	else {
		m = 0.25;
	}
	int dmg = returnDamage(
		getECombatAttackValue(attackChoice),
		getPCombatDefenceValue(defChoice),
		m
	);
	tempPlayerData[0] -= dmg;
	printf("%s%d damage.\n", "The enemy hit you for ", dmg);
}

void attackingTheEnemy() {
	int attackChoice = getPlayerAttackChoice();
	int defChoice = getEnemyDefenceChoice();
	double m;
	if (attackChoice == defChoice) {
		m = 0.25;
	}
	else {
		printf("You blindsided the enemy.\n");
		m = 0.75;
	}
	int dmg = returnDamage(
		getPCombatAttackValue(attackChoice),
		getECombatDefenceValue(defChoice),
		m
	);
	enemies[0] -= dmg;
	printf("%s%d damage.\n", "You a hit the enemy for ", dmg);
}

void setInitialPlayerStats() {
	int i;
	for (i = 0; i <= 8; i++) {
		if (i <= 6) {
			int *ptr = &playerData[i];
			*ptr = 10;
		}
		else {
			int *ptr = &playerData[i];
			*ptr = 0;
		}
	}
	setTempPlayerData();
}


void addSkillPoint(int stat) {
	int *ptr = playerData;
	*(ptr + stat) += 1;
	setTempPlayerData();
}


void setTempPlayerData() {
	int i = 0;
	for (i = 0; i <= 5; i++) {
		tempPlayerData[i] = playerData[i];
	}
}

int getPlayerValueAtN(int n) {
	return playerData[n];
}


int combatScreen() { //Return 0 if the player continues and 1 if not
	setInitialEnemies();
	setTempPlayerData();
	placeArmourOnTemp();
	int speedAp = getPlayerValueAtN(Agility) / 10 + 1, speedAe = getEnemyValueAtN(Agility) / 10 + 1;
	int maxSpeedTotal = returnLCM(speedAp, speedAe);
	int speedE = maxSpeedTotal, speedP = maxSpeedTotal;

	do {
		system("cls");
		if (tempPlayerData[Health] <= 0) {
			return 1;
		}
		else if (speedP <= speedAp) {
			printCombatHeader(tempPlayerData, enemies);
			attackingTheEnemy();
			speedP = maxSpeedTotal;
			printf("Press ENTER key to Continue\n");
			getchar();
			getchar();
		}
		else {
			speedP -= speedAp;
		}
		if (enemies[Health] < 1) {
			printf("\nThe enemy won't fight another day.\n");
			printf("You received %d gold.\n", avgBaseStats());
			modPlayerStats(7, avgBaseStats());
			return 0;
		}
		else if (speedE <= speedAe) {
			printCombatHeader(tempPlayerData, enemies);
			attackingThePlayer();
			speedE = maxSpeedTotal;
			printf("Press ENTER key to Continue\n");
			getchar();
			getchar();
		}
		else {
			speedE -= speedAe;
		}

	} while (true);

}

void initailizingGame();


void returnStatBlessing(int n[], ID id) {
	n[godsArray[id].statOne] *= (1 + godsArray[id].statOneBoost) / 100;
	n[godsArray[id].statTwo] *= (1 + godsArray[id].statTwoBoost) / 100;
}

enum tiletype {
	blank = 0, road, statue, home, fountain, shop
};
typedef enum tiletype tileType;

char *returnTileType(tileType TT) {
	switch (TT) {
	case blank:
		return "Blank";
	case road:
		return "Road";
	case statue:
		return "Statue";
	case home:
		return "Home";
	case fountain:
		return "Fountain";
	case shop:
		return "Shop";
	}
}

struct tile {
	int xPos;
	int yPos;
	tileType TileType;
	int tileSubType;
	bool passable;
	bool containsPlayer;
};
typedef struct tile Tile;
static struct tile map[31][31];

bool validTilePlacement(int x, int y) {
	if (map[x][y].TileType != blank) {
		return false;
	}
	if (map[x + 1][y].TileType == road) {
		return true;
	}
	else if (map[x - 1][y].TileType == road) {
		return true;
	}
	else if (map[x][y - 1].TileType == road) {
		return true;
	}
	else if (map[x][y + 1].TileType == road) {
		return true;
	}
	return false;

}

void setStatues() {
	Tile tileTemp;
	int i;
	for (i = 0; i <= 10;) {
		int x = (rand() % 30) + 1, y = (rand() % 30) + 1;
		if (validTilePlacement(x, y) == true) {
			tileTemp.xPos = x;
			tileTemp.yPos = y;
			tileTemp.TileType = statue;
			tileTemp.tileSubType = i;
			tileTemp.passable = true;
			tileTemp.containsPlayer = false;
			map[x][y] = tileTemp;
			i++;

		}
	}
}

void setMarkets() {
	Tile tileTemp;
	int i, j;
	for (j = 0; j < 5; j++) {
		for (i = 0; i <= 6;) {
			int x = (rand() % 30) + 1, y = (rand() % 30) + 1;
			if (validTilePlacement(x, y) == true) {
				tileTemp.xPos = x;
				tileTemp.yPos = y;
				tileTemp.TileType = shop;
				tileTemp.tileSubType = i;
				tileTemp.passable = true;
				tileTemp.containsPlayer = false;
				map[x][y] = tileTemp;
				i++;

			}
		}
	}
}

void setHomes() {
	Tile tileTemp;
	int i, j;
	for (j = 0; j < 15; j++) {
		for (i = 0; i <= 7;) {
			int x = (rand() % 30) + 1, y = (rand() % 30) + 1;
			if (validTilePlacement(x, y) == true) {
				tileTemp.xPos = x;
				tileTemp.yPos = y;
				tileTemp.TileType = home;
				tileTemp.tileSubType = i;
				tileTemp.passable = true;
				tileTemp.containsPlayer = false;
				map[x][y] = tileTemp;
				i++;

			}
		}
	}
}

void createPath() {
	int i;
	struct tile pathTile;
	pathTile.TileType = road;
	pathTile.passable = true;
	pathTile.tileSubType = 0;
	pathTile.containsPlayer = false;

	for (i = 0; i <= 30; i += 5) {
		int j = 0;
		for (j = 0; j <= 30; j++) {
			pathTile.xPos = i;
			pathTile.yPos = j;
			map[i][j] = pathTile;
			pathTile.xPos = j;
			pathTile.yPos = i;
			map[j][i] = pathTile;

		}
	}
}

void initailGrid() {
	createPath();
	setHomes();
	setMarkets();
	setStatues();
}

void initailizingGame() {

	setInitialPlayerStats();
	setInitialEnemies();
	initailGrid();
}


void printMap() {

	createPath();
	setHomes();
	setMarkets();
	setStatues();
	int i, j;
	for (i = 0; i <= 30; i++) {
		for (j = 0; j <= 30; j++) {
			printf("| %d.%d ", map[i][j].TileType, map[i][j].tileSubType);
		}
		printf("\n");
	}
}

void swapArmourPrompt(armour armour) {
	printSwapArmour(armour);
	printArmourSwap();
	int choice = returnValidImport(1);
	if (choice == 0) {
		printf("Armour Swapped\n");
		setArmour(armour);
	}
	else {
		printf("Armour Not Swapped\n");
	}
	clear();
}

void hasGodsBlessing(int n) {
	char *GodsName = returnGodBlessing(n);
	if (hasBlessing(n) == true) {
		printGodsBlessing(GodsName);
		if (receiveArmour(n) == true) {
			printGodBlessedWArmour();
			swapArmourPrompt(returnGodsArmour(n));
		}
		else {
			printGodBlessedWStat();
			returnStatBlessing(playerData, n);
		}
	}
}


void statueEvent(int subType) {
	printGodsStatue(returnGodBlessing(subType));
	int choice = returnValidImport(2);
	switch (choice) {
	case 0:
		hasGodsBlessing(subType);
		break;
	case 1:
		break;
	case 2:
		printf("The gods are not accepting challengers right now.\n");
		//todo Combat of the Gods
		break;

	}

}

void shopEvent(int subType) {
	printShop(returnArmourType(subType));
	int choice = returnValidImport(1);
	if (choice == 0) {
		shopArmour(subType);
	}

}

void addStatPoint(int nSkillPoints) {
	int choice = 0;
	if (nSkillPoints > 1) {
		printf("You have received %d skill points.\n", nSkillPoints);
	}
	else {
		printf("You have received a skill.\n");
	}
	printf("What skill would you like to upgrade?\n");
	do {
		printPlayerHeader(playerData);
		printStatUpgrade();
		choice = returnValidImport(6);
		if (choice == -1) {
			continue;
		}
		addSkillPoint(choice);
		nSkillPoints--;
		if (nSkillPoints > 1) {

			printf("Remaining skill point :%d\n", nSkillPoints);
		}
		clear();
	} while (nSkillPoints > 0);
}

void homeEvent(int subType) {
	printHome();
	int choice = returnValidImport(1);
	if (choice == 0) {
		printf("The home owner offered some training.\n");
		addStatPoint(subType);
	}
}

void activateEvent(Tile currentTile) {
	if (currentTile.TileType != road) {
		switch (currentTile.TileType) {
		case statue:
			statueEvent(currentTile.tileSubType);
			break;
		case shop:
			shopEvent(currentTile.tileSubType);
			break;
		case home:
			homeEvent(currentTile.tileSubType);

		}
	}
}

void movePlayer() {
	int x = 15, y = 15, movesLeft = getPlayerValueAtN(Agility), movementCost = 1;
	printf("You were place in the center of town to explore until nightfall.\n"
		"It will become harder to move a you began to explore.\n");
	map[x][y].containsPlayer = true;
	while (movesLeft > movementCost) {
		printCardinalTile(returnTileType(map[x + 1][y].TileType),
			returnTileType(map[x][y + 1].TileType),
			returnTileType(map[x - 1][y].TileType),
			returnTileType(map[x][y - 1].TileType));
		int choice = returnValidImport(3);
		switch (choice) {
		case 0:
			if (map[x + 1][y].passable == true) {
				x++;
				break;
			}
			continue;
		case 1:
			if (map[x][y + 1].passable == true) {
				y++;
				break;
			}
			continue;
		case 2:
			if (map[x - 1][y].passable == true) {
				x--;
				break;
			}
			continue;
		case 3:
			if (map[x][y - 1].passable == true) {
				y--;
				break;
			}
			continue;
		}
		clear();
		activateEvent(map[x][y]);
		movesLeft -= movementCost;
		movementCost++;

	}
	printf("Night fall has occurred, Good Night.\n");
	getchar();
	clear();
}


enum Stats;




void printIntArray(int array[], int sizeArray) {
	int i;
	for (i = 0; i < sizeArray; i++) {
		printf("Number %d: %d, ", i, array[i]);
	}
	printf("\n");
}





void applyGodsArmour(int n) {
	armour newArmour = returnGodsArmour(n);
	setArmour(newArmour);
};


int main() {
	initailizingGame();
	printIntroScreen();
	srand(time(0));
	int i = 0;
	while (i == 0) {
		i = combatScreen();
		if (i != 0) {
			break;
		}
		movePlayer();

	}


}



